# Windsurf Rules

## Project Overview

This is a project using Next.js, TypeScript, React and a monorepo structure with Turborepo and pnpm workspaces.

## Technology Stack

- Framework: Next.js App Router, TypeScript, React, Node.js
- UI: Shadcn UI, Tailwind CSS
- Key libraries: React Hook Form, Zod, Lucide React, NiceModal, Nuqs
- Database: Drizzle ORM
- Monorepo: Turborepo with pnpm workspaces
- Namespace: `@workspace/*`

## Project Structure Rules

### Workspace Organization

```
/apps                   # Applications (executable)
  /dashboard            # Main web application
  /marketing            # Marketing pages
  /public-api           # Public API

/packages               # Shared packages
  /api-keys             # API key management
  /auth                 # Authentication logic
  /billing              # Payment handling
  /database             # Drizzle schema & client
  /ui                   # Design system (shadcn/ui)
  /webhooks             # Webhook helpers

/tooling                # Configuration packages
  /eslint-config        # Linting rules
  /typescript-config    # TypeScript presets
```

### File Naming Conventions

- Use kebab-case for file names: `add-item-form.tsx`
- Schema files: `*-schema.ts` (e.g., `add-item-schema.ts`)
- Action files: `*.ts` in `/actions` folder
- Data fetching: `get-*.ts` in `/data` folder
- DTOs: `*-dto.ts` in `/types/dtos`

## Data Fetching Rules

### Server Components (Primary Pattern)

- Use React Server Components for data fetching
- Create data fetching functions in `/data` folder
- Always define explicit DTOs for type safety
- Use Zod schemas for input validation
- Implement proper error handling

```typescript
// Example: apps/dashboard/data/items/get-items.ts
import { getAuthOrganizationContext } from "@workspace/auth/context";
import { db, eq, asc } from "@workspace/database/client";
import { itemTable } from "@workspace/database/schema";
import type { ItemDto } from "~/types/dtos/item-dto";

export async function getItems(): Promise<ItemDto[]> {
  const ctx = await getAuthOrganizationContext();
  return await db
    .select({
      id: itemTable.id,
      name: itemTable.name,
    })
    .from(itemTable)
    .where(eq(itemTable.organizationId, ctx.organization.id))
    .orderBy(asc(itemTable.name));
}
```

### Caching Strategy

- Use `unstable_cache` for server-side caching
- Implement cache tags for revalidation
- Use organization-scoped cache keys

```typescript
// Example with caching
import { unstable_cache } from "next/cache";
import { Caching, OrganizationCacheKey } from "@workspace/common/caching";

export async function getItems(input: GetItemsSchema): Promise<ItemDto[]> {
  const ctx = await getAuthOrganizationContext();
  const result = getItemsSchema.safeParse(input);
  if (!result.success) {
    throw new ValidationError(JSON.stringify(result.error.flatten()));
  }
  const parsedInput = result.data;

  return unstable_cache(
    async () => {
      return await db
        .select({
          id: itemTable.id,
          name: itemTable.name,
        })
        .from(itemTable)
        .where(
          and(
            eq(itemTable.organizationId, ctx.organization.id),
            parsedInput.searchQuery
              ? sql`(${itemTable.name} ILIKE ${
                  "%" + parsedInput.searchQuery + "%"
                }`
              : undefined,
          ),
        )
        .orderBy(asc(itemTable.name));
    },
    Caching.createOrganizationKeyParts(
      OrganizationCacheKey.Items,
      ctx.organization.id,
      parsedInput.searchQuery,
    ),
    {
      tags: [
        Caching.createOrganizationTag(
          OrganizationCacheKey.Items,
          ctx.organization.id,
        ),
      ],
    },
  );
}
```

### Authentication Context

- Use `getAuthContext()` for user-specific data
- Use `getAuthOrganizationContext()` for organization-specific data
- Always validate organization membership

## Mutation Rules

### Server Actions (Primary Pattern)

- Use Next Safe Action for type-safe server actions
- Always add `'use server'` directive
- Use appropriate action clients:
  - `actionClient` - Basic actions
  - `authActionClient` - Authenticated actions
  - `authOrganizationActionClient` - Organization-scoped actions

```typescript
// Example: apps/dashboard/actions/items/add-item.ts
"use server";
import { db } from "@workspace/database/client";
import { itemTable } from "@workspace/database/schema";
import { authOrganizationActionClient } from "~/actions/safe-action";
import { addItemSchema } from "~/schemas/items/add-item-schema";

export const addItem = authOrganizationActionClient
  .metadata({ actionName: "addItem" })
  .inputSchema(addItemSchema)
  .action(async ({ parsedInput, ctx }) => {
    const newItem = await db
      .insert(itemTable)
      .values({
        organizationId: ctx.organization.id,
        name: parsedInput.name,
      })
      .returning();

    return newItem[0];
  });
```

### Drizzle Database Operations

#### Insert Operations

```typescript
// Single insert
const newItem = await db
  .insert(itemTable)
  .values({
    organizationId: ctx.organization.id,
    name: parsedInput.name,
  })
  .returning();

// Multiple insert
const newItems = await db
  .insert(itemTable)
  .values([
    { organizationId: ctx.organization.id, name: "Item 1" },
    { organizationId: ctx.organization.id, name: "Item 2" },
  ])
  .returning();
```

#### Update Operations

```typescript
// Update with where clause
await db
  .update(itemTable)
  .set({
    name: parsedInput.name,
    updatedAt: new Date(),
  })
  .where(
    and(
      eq(itemTable.id, parsedInput.id),
      eq(itemTable.organizationId, ctx.organization.id),
    ),
  );
```

#### Delete Operations

```typescript
// Delete with where clause
await db
  .delete(itemTable)
  .where(
    and(
      eq(itemTable.id, parsedInput.id),
      eq(itemTable.organizationId, ctx.organization.id),
    ),
  );
```

#### Query Operations

```typescript
// Select with joins
const itemsWithDetails = await db
  .select({
    id: itemTable.id,
    name: itemTable.name,
    categoryName: categoryTable.name,
  })
  .from(itemTable)
  .leftJoin(categoryTable, eq(itemTable.categoryId, categoryTable.id))
  .where(eq(itemTable.organizationId, ctx.organization.id))
  .orderBy(asc(itemTable.name));

// Complex where conditions
const filteredItems = await db
  .select()
  .from(itemTable)
  .where(
    and(
      eq(itemTable.organizationId, ctx.organization.id),
      or(eq(itemTable.status, "active"), eq(itemTable.status, "pending")),
      gte(itemTable.createdAt, new Date("2024-01-01")),
    ),
  );
```

### Security Rules

- Never trust user input for `organizationId` or `userId`
- Always use context values: `ctx.organization.id`, `ctx.session.user.id`
- Include organization/user filters in database queries using `and()` and `eq()`
- Validate all inputs with Zod schemas

```typescript
// Always include organization filter in queries
.where(
  and(
    eq(itemTable.organizationId, ctx.organization.id),
    eq(itemTable.id, parsedInput.id)
  )
)
```

## State Management Rules

### URL State (Primary)

- Use search params for shareable state with Nuqs library
- Create `searchParamsCache` for server components
- Use `useQueryState` hook for client components
- Always provide transitions for non-blocking UI

```typescript
// Server component
const searchParamsCache = createSearchParamsCache({
  searchQuery: parseAsString.withDefault(""),
});

// Client component
const [searchQuery, setSearchQuery] = useQueryState("searchQuery", {
  startTransition: transition.startTransition,
  shallow: false,
});
```

### Component State

- Use React state (`useState`, `useReducer`) for local state
- Avoid global state unless absolutely necessary

## Form Rules

### Form Implementation

- Use React Hook Form with `useZodForm` hook
- Always create separate Zod schemas in `/schemas` folder
- Use Shadcn UI form components (`FormField`, `FormControl`, etc.)
- Implement proper error handling and validation

```typescript
// Schema definition
export const addItemSchema = z.object({
  name: z.string().min(2, "Name must be at least 2 characters"),
});

// Form component
const methods = useZodForm({
  schema: addItemSchema,
  mode: "onSubmit",
});
```

## Modal Rules

### Modal Implementation

- Use NiceModal for modal management
- Create responsive modals (Dialog for desktop, Drawer for mobile)
- Use `useEnhancedModal` hook
- Always implement proper form handling within modals

```typescript
export const AddItemModal = NiceModal.create<AddItemModalProps>(({ name }) => {
  const modal = useEnhancedModal();
  const mdUp = useMediaQuery(MediaQueries.MdUp, { ssr: false });
  // Implementation
});
```

## UI Component Rules

### Component Organization

- Reusable components go in `@workspace/ui` package
- App-specific components in respective app folders
- Use proper TypeScript interfaces for props
- Follow Shadcn UI patterns and conventions

### Styling Rules

- Use Tailwind CSS for styling
- Prefer utility classes over custom CSS
- Use `cn()` utility for conditional classes
- Follow responsive design patterns

## Import Rules

### Import Order

1. React imports
2. Third-party libraries
3. Workspace packages (`@workspace/*`)
4. Relative imports (`~/`)

### Drizzle Import Patterns

```typescript
// Database client and operators
import { db, eq, and, or, asc, desc, sql } from "@workspace/database/client";

// Table schemas
import { itemTable, categoryTable } from "@workspace/database/schema";

// Common operators you'll use:
// - eq, ne, gt, gte, lt, lte
// - and, or, not
// - asc, desc
// - sql for raw SQL
// - like, ilike for pattern matching
// - inArray, notInArray
// - isNull, isNotNull
```

## Error Handling Rules

- Use `ValidationError` from `@workspace/common/errors`
- Always validate inputs with Zod
- Implement proper error boundaries
- Handle Drizzle-specific errors appropriately

## Code Quality Rules

### TypeScript

- Use strict TypeScript configuration
- Define proper interfaces and types
- Avoid `any` type usage
- Use type guards when necessary

### Code Organization

- Keep functions small and focused
- Use descriptive names for variables and functions
- Implement proper separation of concerns
- Follow single responsibility principle
